<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>思而勤工作室</title>
	<link rel="stylesheet" href="blog.css">
</head>
<body>
<div id="container">
<a href="index.html">回目录</a>
<h1>参禅悟道——关于服务，对象和类型</h1>
<div><p>1.<br />
服务器的价值在它有某种功能。<br />
它的功能体现在对符合格式的输入，能给出合理的输出。<br />
为了有输入输出的可能性，服务器需要监听一个端口。<br />
2.<br />
如果不是过于简单的功能，对到来的请求，服务器需要判断其类型，进行适当的处置。<br />
这就需要将请求映射到方法的规则，这个规则可以称为路由，而完成请求映射的工作的组件可以称为请求分发器。<br />
3.<br />
由于直接监视某个端口的函数注定是单点，而请求类型较多，响应方法不唯一，所以请求映射可以看做类似if或switch的选择。<br />
如果是选择套选择，实际的逻辑就是树状，监听端口的函数是树根，响应方法是树叶，其间经过不止一次分发。<br />
这种形式的路由定义，在配置文件中会体现树的结构，即一对多再对多，程序中对应的组件们也呈这种结构。<br />
比如tomcat的四级容器engine/host/context/wrapper，前三级定义在server.xml里，最后一级定义在web.xml里。<br />
4.<br />
响应方法如果是用户定义的，这个方法将在某个请求到来时，由于路由的判断，而被服务器调用。<br />
所以本质是回调函数，其参数由服务器制作，响应值也交给服务器处理。<br />
控制权在服务器手里，程序员只能决定整个工作中的那个点。<br />
比如servlet，本质是一个回调函数，服务器构造好request和response对象传进来，程序员的任务是依靠这两个对象干点什么。<br />
5.<br />
这个点，当然，比上不足比下有余，对服务器来说，是最卑微的回调函数，但如果某个应用只有一个servlet，由它将请求进一步分给各个控制器，它在该应用中又有个超然的地位。<br />
将被称为这个应用的请求分发器。<br />
这就是各种mvc框架中需要写到web.xml里的那个servlet/filter的角色。<br />
6.<br />
如果把应用当做一个服务器，超然servlet当做监听端口的那个函数，就会发现上面的道理也适用。<br />
同样需要请求分发，这可能是逐级的，比如某个笼统的路径对应某个包，之后细致一点的规则匹配到类，再细致一点的规则匹配到方法。<br />
7.<br />
而服务器中所谓的管道和阀，在servlet这级体现为filter和servlet的过滤器链模式，而更下一级体现为aop。<br />
程序流程三大要素：顺序，选择，循环。<br />
请求分发本质是选择，而过滤器链本质是顺序。<br />
一个流程有N个环节，其中M个环节是有迹可循的，则可以将它们抽出来，通过配置来决定用或者不用，这就是阀，filter，advice的本质。<br />
8.<br />
为什么只有对顺序和选择的封装而没有对循环的封装？<br />
因为服务器的职责是对某个特定请求作出处置，响应的是业务点。<br />
如果进行的不是偶然的业务而是日常的业务呢？<br />
那就是定时任务的工作了。<br />
9.<br />
定时任务的本质是对循环的封装，某种业务以某种规则反复出现，就可以把内容写到方法体里，通过定时任务，反复调这个方法。<br />
10.<br />
所以服务器实际一共三条主线，一是初始化主线，二是应答主线，三是定时任务主线。<br />
初始化主线的意义在让服务器该有的组件得到装配，为后两者提供基石。<br />
所谓主线，就是一些对象，它们彼此持有，最超级的持有者是监听着端口的那个对象，然后合作起来提供服务。<br />
它们合作起来，写完对请求进行响应的方法体，它们的意义在于行为而非状态。<br />
11.<br />
服务器的状态是通过配置文件或硬编码而使组件获得的状态，以及在内存或硬盘中的数据。<br />
前者的意义在让指导组件采取的行为，后者的意义在它们是业务相关的数据。<br />
行为是算法，状态是数据。<br />
12.<br />
一个请求，本质是一堆数据，但这堆数据里有其特定的片段，该片段用于判断该采取的行为。<br />
这就类似解释器的设计模式。请求分发器根据路由映射和这个片段这两者来找到该回调的函数。<br />
所以说这个状态的意义在行为。<br />
有没有行为的意义在状态呢？有，最简单的就是getter和setter方法。<br />
13.<br />
请求数据中除了路由数据外，剩下的就是用于处理的数据。<br />
前者决定到哪个方法，后者决定为该方法传入哪些参数。<br />
一次访问服务器的行为，从宏观上看就是调用了一个方法，该方法可能会有返回值也可能没有，可能让方法所属对象的状态产生变化也可能没有。<br />
这个对象指的就是服务器，其状态指的就是其使用的数据库或缓存之类，物理上是硬盘或内存，逻辑上是个仓库的空间。<br />
当然，实际数据库缓存之类往往也体现为服务，但在上文说的服务器的外部观看，如果把服务器看做黑箱子，是可以忽视这一点的。<br />
14.<br />
当你调一个对象的方法时，可能目的在于：<br />
一、希望改变这个对象的状态；<br />
二、希望从这个方法获得返回；<br />
三、以上两者都有；<br />
把上文的对象换成服务器，第一点就成为增删改，第二点就成为查，第三点是前两点的结合。<br />
15.<br />
所以如果对服务器进行拆分，编辑和查询的分离是理所当然的，这就是读写分离的合理性。<br />
出于性能的考虑，会倾向于减少交互次数，则出现一个方法既有写意义又有读意义的情况。<br />
这本质是两个方法的混合。<br />
16.<br />
读的意义在了解某些信息，写的意义在改变某些信息。<br />
了解和改变属于动词，而具体是哪个信息属于名词。<br />
所以REST的动词加资源标识的意义就是动词名词的分离，前者决定请求方法，后者为之输入参数。<br />
17.<br />
这个世界，动词体现在时间上，名词体现在空间上。<br />
三维加一维等于四维。<br />
数据加算法等于程序。<br />
18.<br />
面向对象，就是面向现实。<br />
贫血对象就像要塞入绞肉机里的鱼肉，只被主宰，没有主见。<br />
充血对象则有对世界造成影响的能力。<br />
贫血对象的正确性在于，对基于请求响应模式的交互来说，一次交互本质是一个行为，所以设计重点在对行为进行构造。<br />
贫血对象的角色，本质是对数据库即服务器状态的代理，作为状态，要为行为让路。<br />
在面向行为的场景中，呆滞麻木任人宰割的状态型对象是合理的。<br />
19.<br />
抽象的意义在让世界更清晰，抽象的坏处是让世界变得割裂。<br />
认识可能对真相造成破坏，却是必须做的工作。<br />
所以让对象属于类是合理的。<br />
弱类型的意义在软件工程上更灵活，而不是在逻辑上更正确。<br />
软件工程上的弱类型，与其说没有类型，不如说所有对象都属于一个类型&mdash;&mdash;map，这不是不抽象，反而正是最暴力的抽象。<br />
正因如此，使用map作为参数和返回值进行方法设计，可以包容最多的可能性。<br />
多态性多到变态。<br />
20.<br />
世界上无数种东西，如果分成一亿类，没人记得清，不实用。<br />
但如果分成一个类统统叫&ldquo;东西&rdquo;，则没有任何帮助，同样不实用。<br />
但现在各个方面都在去类型化，弱类型语言大行其道，流行的nosql数据库本质也是去了类型的数据库。<br />
关系型数据库中某个表有多少个列的规定，本质与强类型无二。<br />
造成去类型化现象的原因，一是程序员水平提高，二是世界变化太快，三可能是因为不愿多虑的唯速度至上的软件工程思维大行其道。</p>
</div>
</div>
</body>
</html>