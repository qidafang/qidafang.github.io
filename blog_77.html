<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>思而勤工作室</title>
	<link rel="stylesheet" href="blog.css">
</head>
<body>
<div id="container">
<a href="index.html">回目录</a>
<h1>相比起沉重的cometd,小巧的come</h1>
<div><p>相比起沉重的cometd,小巧的comet4j就太让人喜欢了，虽然只支持tomcat6和7。<br />
<br />
几大亮点：<br />
1.不依赖第三方库，而且代码还简单清楚，简单轻便永远是招人喜欢的。<br />
2.API简单专注，只做了服务器推这件事，连浏览器向服务器发独立的请求都不管。<br />
2.定位在类库而不是框架，体现在声明了一些在任何代码中都能调用的对象（经典单例模式），侵入性极小。被控制反转搞得情绪低落的程序员会对重新做主人充满幸福感。<br />
3.思路简洁清晰，标准的长连接模式，容易理解和扩展。<br />
<br />
使用的几个关键点：<br />
1.因为只做了&ldquo;服务器推浏览器接&rdquo;的事，强迫你自己从头做&ldquo;浏览器请求服务器响应&rdquo;的工作，使两个活动天然解耦，避免了混杂不清的危险。两个活动的耦合点在哪里？当然是服务器持有的&ldquo;状态&rdquo;的变化，前一活动监听该状态决定推不推，后一活动改变该状态。这状态的承载者是啥？当然啥都可以了，static的变量啊，数据库啊，缓存啊，nosql啊&hellip;&hellip;<br />
2.怎么做&ldquo;只对特定的客户端推&rdquo;而不是&ldquo;无脑广播&rdquo;的工作？要甄别客户端，客户端首先要让服务器知道自己的特殊性，每个客户端有一个唯一的cId，对应的是服务器保持的connector对象的id（实现中由于是多次请求，connector对象实际是先后有多个，但逻辑上对应同一客户端的connector们，其id都是一样的）。服务器可以通过这个id，筛选特定的connector向它们推信息。至于怎么用这个id，当然还是运用之妙、存乎一心。<br />
3.一种可能的用法是客户端的某个请求附带cId，提醒服务器自己的存在，服务器将该cId存到某个状态里，当服务器要推信息的时候，从该状态中取得cId，再获得connector，再向connector推。<br />
4.在需要comet的场景下，实际服务器是需要状态的（与经典request-response不需要状态不同），服务器端有&ldquo;环境实体&rdquo;例如&ldquo;一局游戏&rdquo;&ldquo;一个聊天室&rdquo;的概念，该&ldquo;环境实体&rdquo;的特点是需要有个状态甲保持客户端们的信息，另外还需要个状态乙，保持客户端们所共同关注的东西，即业务场景中的概念。既然状态甲是理所当然的，服务器只要好好持有&ldquo;环境实体&rdquo;，就自然能得到客户端列表。<br />
5.不考虑性能，环境实体适合存放数据库中，这样就好理解了。服务器端怎么触发推消息的动作呢？一是定时触发，二是监听特定状态的改变而触发，三是响应客户端请求时触发。三不好，耦合高。一和二看场景。二较好一些，即所谓不断阻塞的主循环，这时用于标志的状态就非常重要，注意多线程的问题。</p>
</div>
</div>
</body>
</html>