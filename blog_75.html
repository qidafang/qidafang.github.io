<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>思而勤工作室</title>
	<link rel="stylesheet" href="blog.css">
</head>
<body>
<div id="container">
<a href="index.html">回目录</a>
<h1>shiro</h1>
<div><p>参考：<a href="http://jinnianshilongnian.iteye.com/category/305053" target="_blank">&ldquo;今年是龙年&rdquo;的这个系列博文</a>非常好。<br />
<br />
shiro本质上不晦涩。<br />
<br />
运行时的shiro的体现就是一个过滤器，检查发起http请求的人：<br />
1)是否已登录<br />
2)是否有权限访问请求的url<br />
<br />
当然了，以下问题是shiro不能决定的，程序员必须来决定：<br />
1)哪些url需要登录才能访问，哪些url需要特定的角色/权限才能访问。<br />
2)页面的哪些片段需要登录才能显示，哪些片段需要特定的角色/权限才显示。<br />
3)用户提交登录的http请求都包括哪些内容。<br />
4)对用户提交的请求，该怎样判断是否能够登录。<br />
5)已登录的人都有哪些角色/权限。<br />
6)密码的存储怎样加密。<br />
<br />
回答这些问题是shiro不可能替程序员简化的的，shiro的价值在：<br />
1)能简化的都简化了。<br />
2)不能简化的标准需求，为用户留出自定义的接口。<br />
3)非标准的需求也尽可能考虑到，预留扩展点让用户扩展。<br />
<br />
上面说的是最核心的东西，另外还有些可选的东西：<br />
1)缓存<br />
2)记住我<br />
3)单点登录<br />
...<br />
不一一列举<br />
<br />
个人未必对的思考和笔记：<br />
1.SecurityManager，shiro的核心，实际干活的就是它。<br />
2.Realm：检察官；Token：登录申请；Subject：申请人。Realm和Token当然该由用户自己实现，前者实现动词（检查策略），后者实现名词（申请内容的结构）。<br />
3.url映射到拦截器上，标准拦截器基本够用，自定义拦截器也不难。<br />
4.验证和授权的单词非常相似，记忆方法有c的是验证，有z的是授权。<br />
5.验证回答&ldquo;你存在？&rdquo;的问题，授权回答&ldquo;你有资格？&rdquo;的问题。<br />
6.Realm定义验证策略，即针对一个登录申请Token，怎么判断它是否确实能登录。登录时它说了算。<br />
7.自定义的拦截器定义拦截策略，即什么样的请求算通过，不通过的该怎么办。平常访问它说了算。<br />
8.登录毕竟复杂度有限，shiro为了兼容最多可能，显得内容稍微有点多，其实都很好理解。<br />
<br />
明天要着手做的事：<br />
1.同一个web项目，前台、后台、ajax的访问，都用shiro管起来。<br />
2.还是这个web项目，无状态的webservice交互接口，用shiro管起来。</p>
</div>
</div>
</body>
</html>