<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>思而勤工作室</title>
	<link rel="stylesheet" href="blog.css">
</head>
<body>
<div id="container">
<a href="index.html">回目录</a>
<h1>java多线程并发那点事儿</h1>
<div><p>1.多线程的本质是多个控制流<br />
2.多线程的意义在多个控制流共享内存，相互合作<br />
3.其危险在由于共享了内存，可能互相影响<br />
4.java web程序先天多线程，每个请求一个线程，为什么一般不用考虑危险？因为行为对象无状态，有状态的只有数据库，数据库并发问题直接由事务管起来了。<br />
5.多线程安全问题的解决思路，首先是釜底抽薪，彻底消灭危险：<br />
1)不在线程间共享对象<br />
2)在线程间共享对象，但共享的都是无状态对象<br />
3)在线程间共享对象，共享的是有状态对象，但其状态都是final的<br />
6.不得不共享状态可变的对象的话，必须遵循：<strong>其属性都是private的，访问属性的方法都是synchronized的</strong><br />
7.而且方法应该是原子的，这类似事务的原子性，如果被连续调两个方法，还是有危险，要封装成一个方法，供外部调用<br />
8.java提供的工具们：<br />
1)xx.wait&amp;xx.notify<br />
xx.wait代表当前线程因xx的缘故（指xx的属性）而等待，监视xx，用在无限循环中。<br />
xx.notify代表&ldquo;xx的情况有变化了，你再试试吧&rdquo;来通知wait的线程。被唤醒的线程将立刻进入循环的判断部分，如果判断&ldquo;好了&rdquo;，则做该做的事，否则翻个身继续wait。<br />
2)synchronized(xx)<br />
用于将xx对象独享，在释放之前谁都别想用，如果它被别人独享呢，我就安静地等着，随时欢迎它被释放。<br />
当xx是多个线程都可以访问的对象时必须这么用，保证其中代码运行时xx不被别的线程改变，与事务的加锁概念一致。<br />
当锁住一个对象，&ldquo;它是我的了，你们别过来&rdquo;，其他线程都得等着。<br />
3)BlockingQueue：用于生产者-消费者模式，如果队列里没东西，取的线程会阻塞，直到有人往里放了东西为止。<br />
4)线程安全的集合，最常用的是ConcurrentHashMap和CopyOnWriteArrayList，后者仅适用于迭代操作远远多于修改操作时。<br />
5)Callable：有返回值的线程，意义在将串行的方法体改为并行，例如原来需要依次做ABCD四件事各一秒钟，并行后可以将总时间由四秒缩短为一秒。<br />
6)ThreadPool：线程池，池的意义都在于节约资源而不是做到本来做不到的事，不多说。<br />
7)自己写线程安全的类，关键点在属性都private，方法都synchronized，每次只让外部用一个方法，而且别把属性放出去。</p>

<p><strong>参考：</strong>书籍《java并发编程实战》，笔记<a href="http://zidafone.com/share/note/152">在这里</a><br />
书籍《java核心技术》第14章&ldquo;多线程&rdquo;</p>

<p><br />
<strong>后记：</strong><br />
以前一直觉得线程是一个&ldquo;超乎程序员控制范围之内&rdquo;的存在，只有我写代码在其中执行，而不能写代码来控制它。原来不然。<br />
<strong>新的线程只是一个&ldquo;帮手&rdquo;</strong>，它也有属性，也可以被你持有。<br />
它的特点是可以自顾自运行，而不是必须等到用户发了什么指令才做出响应，所以常被称为&ldquo;后台线程&rdquo;，用于完成一些任务。<br />
后台线程能发挥作用的重点是能访问某些对象，这些对象常常在构造帮手时传入帮手，这对象既然要被后台线程访问，也要被主线程访问，就必须是线程安全的。<br />
这跟数据库既会被这个操作改变，又会被那个操作改变，所以必须用事务来保护，是一个性质。对象和数据库，都是状态的持有者，当状态不是被封在一个线程内部，就存在互相影响的问题。<br />
ACID四大特性，除了持久性之外，原子性，一致性，隔离性，都是并发编程时要保障的。<br />
解决办法也简单，就是将关键对象作成<strong>线程安全对象：属性全私有，方法全同步，属性不放出去</strong>。<br />
其实synchronized可以解决一切，其他的技术都是让事情变简单，而不是要解决synchronized解决不了的问题。<br />
一句话概括：<span style="color:#FF0000"><strong>多线程并发的要点在对共享的内存的控制，该事情synchronized可以做得完美，通过对该内存加锁的方式。</strong></span></p>
</div>
</div>
</body>
</html>