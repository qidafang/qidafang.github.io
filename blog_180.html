<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>思而勤工作室</title>
	<link rel="stylesheet" href="blog.css">
</head>
<body>
<div id="container">
<a href="index.html">回目录</a>
<h1>《java编程思想》并发章节笔记</h1>
<div><p><span style="color:#FF0000"><strong><span style="font-size:14px"><span style="font-family:arial,helvetica,sans-serif">感想：《java编程思想》的章节安排得熟练又合理，详略得当，虽然可能老了一点，但依然是《Core Java》比不了的，尽管后者在&ldquo;说其然&rdquo;方面做得不错，但&ldquo;说其所以然&rdquo;方面差很多。</span></span></strong></span></p>

<p>并行编程可以使程序执行速度得到极大提高，或者为设计某些类型的程序提供更易用的模型，或者两者皆有。<br />
学习并发编程就像进入了一个全新的领域，有点类似于学习一门新的编程语言，或者至少是学习一整套新的语言概念。<br />
<strong>1.并发的多面性</strong><br />
用并发解决的问题大体上可以分为&ldquo;速度&rdquo;和&ldquo;设计可管理性&rdquo;两种。<br />
更快的执行：如果程序中的某个人物因为该程序控制范围之外的某些条件（通常是I/O）而导致不能继续执行，那么我们就说这个任务或线程阻塞了。如果没有并发，则整个程序都将停止下来，直至外部条件发生变化。但是，如果使用并发来编写程序，那么当一个任务阻塞时，程序中的其他任务还可以继续执行，如果没有任务会阻塞，那么在单处理器机器上使用并发就没有任何意义。<br />
改进代码设计：并发提供了一个重要的组织结构上的好处：你的程序设计可以极大地简化。仿真通常涉及许多交互式元素，每一个都有&ldquo;其自己的想法&rdquo;。通常，线程使你能够创建更加松散耦合的设计，否则，你的代码中各个部分都必须显式地关注那些通常可以由线程来处理的任务。<br />
<strong>2.基本的线程机制</strong><br />
并发编程使我们可以将程序划分为多个分离的、独立运行的任务。一个线程就是在进程中的一个单一的顺序控制流。你的程序使得每个人物都好像有其自己的CPU一样。<br />
定义任务：使用Runnable接口，通常run方法被写成无限循环的形式。<br />
Thread类：<br />
Executor：为你管理Thread对象。<br />
从任务中产生返回值：使用Callable接口。<br />
休眠：使用sleep方法延迟一定时间。<br />
优先级：<br />
让步：表示你的工作已经差不多了，可以让别的线程使用CPU了。yield()方法。<br />
后台进程：指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部分。因此，当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台进程。setDaemon。<br />
加入一个线程：在其他线程上调用join方法，等待该线程结束。<br />
<strong>3.共享受限资源</strong><br />
在给定时刻只允许一个任务访问共享资源。使用锁。synchronized。<br />
如果你正在写一个变量，它可能接下来被另一个线程读取，或者正在读取一个上一次已经被另一个线程写过的变量，那么你必须使用同步，并且，读写线程都必须用相同的监视器锁同步。<br />
<strong>4.终结</strong><br />
任务阻塞的原因：sleep/wait/等输入输出/等待锁<br />
<strong>5.线程之间的协作</strong><br />
wait()使你可以等待某个条件发生变化，而改变这个条件超出了当前方法的控制能力。wait()会在等待外部世界产生变化的时候将任务挂起，并且只有在notify()或notifyAll()发生时，即表示发生了某些感兴趣的事物，这个任务才会被唤醒并去检查所产生的变化。wait()将释放锁。<br />
可以使用同步队列来解决任务协作问题，任何时刻都只允许一个任务插入或移除元素。<br />
死锁：某个任务在等待另一个任务，而后者又等待别的任务，这样一直下去，直到这个链条上的任务又在等待第一个任务释放锁。这得到了一个任务之间相互等待的连续循环，没有哪个线程能继续。<br />
<strong>jdk提供的工具们：</strong><br />
CountDownLatch，用于并行-汇总型场景，比如ABCDE五个任务，ABCD并发，都做完后做E，则可以初始化一个CountDownLatch(4)，让E等待它，在ABCD完成后各将其减1，减到0时E会被触发，达到目的。<br />
CyclicBarrier，用于并行-汇总-再并行-再汇总..型场景，先分别做A1B1C1D1，然后整体做E1，再分别做A2B2C2D2，然后整体做E2，体现一种齐头并进的关系。<br />
DelayedQueue是将元素按到期时间排列的队列，只有到期的才能拿出去（阻塞的）。<br />
PriorityBlockingQueue是阻塞的优先级队列。<br />
ScheduledExecutor定时任务。<br />
Semaphore许可证，用于实现池，记录总可用数，借用和归还时触发。<br />
Exchanger用于两个线程交换对象，常用于生产者-消费者模式。</p>
</div>
</div>
</body>
</html>